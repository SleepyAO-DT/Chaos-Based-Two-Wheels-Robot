<?xml version="1.0" ?>
<robot name="two_wheeled_robot_base" xmlns:xacro="http://ros.org/wiki/xacro">
	
	<!--机器人宏定义 -->	
	<xacro:property name="M_PI" value="3.1415926"/>
	<!-- 机器人主体长宽高（米） -->
  	<xacro:property name="base_width" value="0.60"/>
  	<xacro:property name="base_length" value="0.60"/>
  	<xacro:property name="base_height" value="0.40"/>
	
  	<!-- 机器人双后轮大小 -->
 	<xacro:property name="wheel_radius" value="0.16"/>
  	<xacro:property name="wheel_width" value="0.08"/>
  	
  	<!--机器人前轮半径-->
  	<xacro:property name="caster_radius"  value="0.06"/> <!-- 直径 = wheel_radius - ( base_height/2 - wheel_zoff) -->
  	
  	<!-- X轴为前进方向，Y轴为前进方向左边，Z轴为竖直向上方向 -->
  	<!-- 定义轮子在各轴上的偏移 -->
  	<xacro:property name="wheel_ygap" value="0.34"/>
  	<xacro:property name="wheel_zoff" value="0.16"/>
  	<xacro:property name="wheel_xoff" value="0.20"/>
  	<xacro:property name="caster_xoff" value="0.18"/>
  	
    <!-- 定义颜色配置 -->
    <material name="yellow">
        <color rgba="1 0.4 0 1"/>
    </material>
    <material name="black">
        <color rgba="0 0 0 0.95"/>
    </material>
    <material name="gray">
        <color rgba="0.75 0.75 0.75 1"/>
    </material>
    <material name="red">
        <color rgba="1.0 0.0 0.0 1.0"/>
    </material>

  	<!-- 定义惯性矩阵函数  -->
  	<xacro:macro name="box_inertia" params="m w h d">
    	<inertial>
      		<mass value="${m}"/>
      		<inertia ixx="${(m/12) * (h*h + d*d)}" ixy="0.0" ixz="0.0" iyy="${(m/12) * (w*w + d*d)}" iyz="0.0" izz="${(m/12) * (w*w + h*h)}"/>
    	</inertial>
  	</xacro:macro>

  	<xacro:macro name="cylinder_inertia" params="m r h">
    	<inertial>
      		<mass value="${m}"/>
      		<inertia ixx="${(m/12) * (3*r*r + h*h)}" ixy = "0" ixz = "0" iyy="${(m/12) * (3*r*r + h*h)}" iyz = "0" izz="${(m/2) * (r*r)}"/>
    	</inertial>
  	</xacro:macro>

  	<xacro:macro name="sphere_inertia" params="m r">
    	<inertial>
      		<mass value="${m}"/>
      		<inertia ixx="${(2/5) * m * (r*r)}" ixy="0.0" ixz="0.0" iyy="${(2/5) * m * (r*r)}" iyz="0.0" izz="${(2/5) * m * (r*r)}"/>
    	</inertial>
  	</xacro:macro>
  	
	    <!-- 定义轮子配置函数 -->
    <xacro:macro name="wheel" params="prefix reflect">
        <joint name="${prefix}_wheel_joint" type="continuous">
            <origin xyz="${-wheel_xoff} ${reflect*wheel_ygap} ${-wheel_zoff}" rpy="0 0 0"/>
            <parent link="base_link"/>
            <child link="${prefix}_wheel_link"/>
            <axis xyz="0 1 0"/>
        </joint>

        <link name="${prefix}_wheel_link">
            <visual>
                <origin xyz="0 0 0" rpy="${M_PI/2} 0 0" />
                <geometry>
                    <cylinder radius="${wheel_radius}" length = "${wheel_width}"/>
                </geometry>
                <material name="gray" />
            </visual>
            <collision>
                <origin xyz="0 0 0" rpy="${M_PI/2} 0 0" />
                <geometry>
                    <cylinder radius="${wheel_radius}" length = "${wheel_width}"/>
                </geometry>
            </collision>
            <xacro:cylinder_inertia  m="5.0" r="${wheel_radius}" h="${wheel_width}" />
        </link>

        <gazebo reference="${prefix}_wheel_link">
            <material>Gazebo/Gray</material>
            <mu1>1.0</mu1>
            <mu2>1.0</mu2>
        </gazebo>

        <!-- Transmission is important to link the joints and the controller -->
        <transmission name="${prefix}_wheel_joint_trans">
            <type>transmission_interface/SimpleTransmission</type>
            <joint name="${prefix}_wheel_joint" >
                <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>
            </joint>
            <actuator name="${prefix}_wheel_joint_motor">
                <hardwareInterface>hardware_interface/VelocityJointInterface</hardwareInterface>
                <mechanicalReduction>1</mechanicalReduction>
            </actuator>
        </transmission>
    </xacro:macro>

    <!-- 定义前支撑轮配置函数 -->
    <xacro:macro name="caster" params="reflect">
        <joint name="caster_joint" type="fixed">
            <origin xyz="${reflect*wheel_xoff} 0 ${-(base_height/2 + caster_radius)}" rpy="0 0 0"/>
            <parent link="base_link"/>
            <child link="caster_link"/>
        </joint>

        <link name="caster_link">
            <visual>
                <origin xyz="0 0 0" rpy="0 0 0"/>
                <geometry>
                    <sphere radius="${caster_radius}" />
                </geometry>
                <material name="black" />
            </visual>
            <collision>
                <origin xyz="0 0 0" rpy="0 0 0"/>
                <geometry>
                    <sphere radius="${caster_radius}" />
                </geometry>
            </collision>      
            <xacro:sphere_inertia  m="3.0" r="${caster_radius}" />
        </link>

        <gazebo reference="caster_link">
            <material>Gazebo/Black</material>
			<mu1>0.02</mu1>
            <mu2>0.02</mu2>
        </gazebo>
    </xacro:macro>
  	
  	<!--机器人主体配置-->
    <xacro:macro name="two_wheel_base">
  	<link name="base_link">
  		<visual>
            <origin xyz=" 0 0 0" rpy="0 0 0" />
            <geometry>
                <box size="${base_length} ${base_width} ${base_height}"/>
            </geometry>
            <material name="red" />
        </visual>
        
        <collision>
            <origin xyz=" 0 0 0" rpy="0 0 0" />
            <geometry>
               <box size="${base_length} ${base_width} ${base_height}"/>
            </geometry>
        </collision>
        
        <xacro:box_inertia  m="20.0" w="${base_width}" d="${base_length}" h="${base_height}"/>
    </link>
    
    <gazebo reference="base_link">
    	<material>Gazebo/red</material>
    </gazebo>
  	
  	<!--机器人Base Footprint 也就是机器人中心在地面的投影，便于里程计的计算等操作-->
  	<link name="base_footprint">
  	    <visual>
                <origin xyz="0 0 0" rpy="0 0 0" />
                <geometry>
                    <box size="0.001 0.001 0.001" />
                </geometry>
            </visual>
	</link>

	<joint name="base_joint" type="fixed">
    	<parent link="base_footprint"/>
    	<child link="base_link"/>
    	<origin xyz="0.0 0.0 ${wheel_radius+wheel_zoff}" rpy="0 0 0"/>
  	</joint>

	<gazebo reference="base_footprint">
            <turnGravityOff>false</turnGravityOff>
        </gazebo>
  	
	<!--调用轮子函数进行快速配置-->
	<xacro:wheel prefix="left" reflect="1"/>
	<xacro:wheel prefix="right" reflect="-1"/>
  	<xacro:caster reflect="1"/>
  	
  	<!--轮子控制配置-->
  	<gazebo>
        <plugin name="differential_drive_controller" 
            filename="libgazebo_ros_diff_drive.so">                
            <update_rate>20</update_rate>
            <left_joint>left_wheel_joint</left_joint>
            <right_joint>right_wheel_joint</right_joint>
            <wheel_separation>${wheel_ygap*2}</wheel_separation>
            <wheel_diameter>${2*wheel_radius}</wheel_diameter>
            <max_wheel_torque>20</max_wheel_torque>
            <max_wheel_acceleration>1.0</max_wheel_acceleration>
            <command_topic>cmd_vel</command_topic>
            <publish_odom>true</publish_odom>
            <publish_odom_tf>true</publish_odom_tf>
            <publish_wheel_tf>true</publish_wheel_tf>
            <odometry_topic>odom</odometry_topic>
            <odometry_frame>odom</odometry_frame>
            <robot_base_frame>base_footprint</robot_base_frame>
            <odometry_source>1</odometry_source>
        </plugin>
    </gazebo>
    </xacro:macro>

</robot>
